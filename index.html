<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Math Checker</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <link rel="apple-touch-icon" href="icons/icon-192.png" />
  <style>
    :root {
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #0f172a;
      --muted: #64748b;
      --ok: #16a34a;
      --bad: #dc2626;
      --brand: #2563eb;
      --brand-weak: #dbeafe;
      --border: #e5e7eb;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: var(--bg);
    }
    .container {
      max-width: 1000px;
      margin: 2rem auto;
      padding: 0 1rem;
      display: grid;
      grid-template-columns: 3fr 2fr;
      grid-gap: 1rem;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }
    h1 { margin: 0 0 0.5rem 0; font-size: 1.5rem; }
    .muted { color: var(--muted); }

    /* Mode Buttons */
    .mode-buttons { display: flex; gap: .5rem; margin: .5rem 0 1rem 0; flex-wrap: wrap; }
    .mode-buttons button {
      border: 1px solid var(--border);
      background: #fff;
      padding: .5rem .8rem;
      border-radius: 9999px;
      cursor: pointer;
    }
    .mode-buttons button.active { background: var(--brand-weak); border-color: var(--brand); color: var(--brand); }

    .question { font-size: 2.25rem; letter-spacing: .5px; text-align: center; margin: 1rem 0; }
    .row { display: flex; gap: .5rem; align-items: center; }
    input[type="number"] {
      width: 140px; padding: .6rem .7rem; font-size: 1.1rem; border-radius: 8px; border: 1px solid var(--border);
    }
    button.primary { background: var(--brand); color: #fff; border: none; padding: .6rem 1rem; border-radius: 8px; cursor: pointer; }
    button.secondary { background: #fff; color: var(--text); border: 1px solid var(--border); padding: .6rem 1rem; border-radius: 8px; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .result { min-height: 1.75rem; font-weight: 600; margin-top: .25rem; }
    .ok { color: var(--ok); }
    .bad { color: var(--bad); }

    .explanation { white-space: pre; font-family: var(--mono); background: #fafafa; border: 1px dashed var(--border); border-radius: 8px; padding: .5rem .75rem; }
    .timer { font-variant-numeric: tabular-nums; }

    .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: .5rem; margin-top: .5rem; }
    .stat {
      border: 1px solid var(--border); border-radius: 10px; padding: .75rem; text-align: center; background: #fff;
    }
    .stat .kpi { font-size: 1.5rem; font-variant-numeric: tabular-nums; }

    /* Scratchpad styles */
    .pad-header { display:flex; align-items:center; justify-content:space-between; margin-top:1rem; }
    #scratchpad {
      width: 100%;
      height: 260px; /* nice finger-writing height on phones */
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 12px;
      touch-action: none; /* important for smooth pointer events on iOS */
      display: block;
      user-select: none; /* avoid text selection while drawing */
      -webkit-user-select: none;
      cursor: crosshair;
    }
    .pad-buttons { display:flex; gap:.5rem; }

    @media (max-width: 820px) {
      .container { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="container">
    <main class="card">
      <h1>Math Checker</h1>
      <div class="muted">Practice quick mental arithmetic. Choose a mode, answer, and track your stats.</div>

      <!-- MODE BUTTONS -->
      <div class="mode-buttons" role="group" aria-label="Mode selector">
        <button id="mode-add" aria-pressed="false">Addition Only</button>
        <button id="mode-sub" aria-pressed="false">Subtraction Only</button>
        <button id="mode-both" aria-pressed="true" class="active">Add &amp; Subtract</button>
      </div>

      <div id="question" class="question">0 + 0</div>

      <div class="row">
        <label for="answer" class="muted" style="width:80px">Answer</label>
        <input id="answer" type="number" inputmode="numeric" min="0" max="999" placeholder="0–999" />
        <button id="checkBtn" class="primary" disabled>Check</button>
        <button id="nextBtn" class="secondary" disabled>Next</button>
        <div class="muted" style="margin-left:auto">Time: <span id="timer" class="timer">0s</span></div>
      </div>

      <div id="result" class="result"></div>
      <div id="correctValue" class="muted" style="min-height:1.25rem"></div>
      <div id="explanation" class="explanation" style="min-height:3.25rem"></div>

      <!-- SCRATCHPAD -->
      <div class="pad-header">
        <div class="muted">Working area (use your finger)</div>
        <div class="pad-buttons">
          <button id="clearPadBtn" class="secondary">Clear</button>
        </div>
      </div>
      <canvas id="scratchpad" aria-label="Handwriting working area"></canvas>

    </main>

    <aside class="card">
      <h2 style="margin-top:0">Statistics</h2>
      <div class="stats-grid">
        <div class="stat"><div class="muted">Total</div><div id="totalCount" class="kpi">0</div></div>
        <div class="stat"><div class="muted">Correct</div><div id="correctCount" class="kpi">0</div></div>
        <div class="stat"><div class="muted">Incorrect</div><div id="incorrectCount" class="kpi">0</div></div>
        <div class="stat"><div class="muted">Accuracy</div><div id="correctRate" class="kpi">0.0%</div></div>
      </div>
      <div class="row" style="margin-top:1rem; justify-content:space-between">
        <button id="resetStats" class="secondary">Reset Stats</button>
      </div>
    </aside>
  </div>

  <script>
    // ------- State -------
    let num1 = 0, num2 = 0, operator = "+", correctResult = 0;
    let answered = false; let timer = null; let seconds = 0;
    let counts = { total: 0, correct: 0, incorrect: 0 };
    let mode = localStorage.getItem("mc_mode") || "both"; // "add" | "sub" | "both"

    // ------- Elements -------
    const questionEl = document.getElementById('question');
    const answerInput = document.getElementById('answer');
    const checkBtn = document.getElementById('checkBtn');
    const nextBtn = document.getElementById('nextBtn');
    const resultEl = document.getElementById('result');
    const correctValueEl = document.getElementById('correctValue');
    const explanationEl = document.getElementById('explanation');
    const timerEl = document.getElementById('timer');

    const totalCountEl = document.getElementById('totalCount');
    const correctCountEl = document.getElementById('correctCount');
    const incorrectCountEl = document.getElementById('incorrectCount');
    const correctRateEl = document.getElementById('correctRate');

    const resetStatsBtn = document.getElementById('resetStats');

    const modeAddBtn = document.getElementById('mode-add');
    const modeSubBtn = document.getElementById('mode-sub');
    const modeBothBtn = document.getElementById('mode-both');

    // Scratchpad elements
    const canvas = document.getElementById('scratchpad');
    const clearPadBtn = document.getElementById('clearPadBtn');
    let ctx; let isDrawing = false; let lastX = 0; let lastY = 0; let dpr = Math.max(1, window.devicePixelRatio || 1);

    // ------- Mode handling -------
    function setMode(selected) {
      mode = selected;
      localStorage.setItem('mc_mode', mode);
      [modeAddBtn, modeSubBtn, modeBothBtn].forEach(b => { b.classList.remove('active'); b.setAttribute('aria-pressed','false'); });
      if (mode === 'add') { modeAddBtn.classList.add('active'); modeAddBtn.setAttribute('aria-pressed','true'); }
      else if (mode === 'sub') { modeSubBtn.classList.add('active'); modeSubBtn.setAttribute('aria-pressed','true'); }
      else { modeBothBtn.classList.add('active'); modeBothBtn.setAttribute('aria-pressed','true'); }
      generateQuestion();
    }

    modeAddBtn.addEventListener('click', () => setMode('add'));
    modeSubBtn.addEventListener('click', () => setMode('sub'));
    modeBothBtn.addEventListener('click', () => setMode('both'));

    // ------- Core logic -------
    function randInt(max) { return Math.floor(Math.random() * (max + 1)); }

    function chooseOperator() {
      if (mode === 'add') return '+';
      if (mode === 'sub') return '-';
      return Math.random() < 0.5 ? '+' : '-';
    }

    function generateQuestion() {
      // Reset UI state
      resultEl.textContent = '';
      resultEl.className = 'result';
      correctValueEl.textContent = '';
      explanationEl.textContent = '';
      answered = false;
      checkBtn.disabled = true; // until user types something valid
      nextBtn.disabled = true;
      answerInput.value = '';
      answerInput.focus();

      // Clear the scratchpad for the new question
      clearCanvas();

      // Build a question according to mode
      num1 = randInt(999);
      num2 = randInt(999);
      operator = chooseOperator();

      if (operator === '-' && num2 > num1) {
        [num1, num2] = [num2, num1]; // avoid negatives
      }

      correctResult = operator === '+' ? (num1 + num2) : (num1 - num2);

      // Ensure result within input bounds (0–999)
      if (correctResult < 0 || correctResult > 999) {
        return generateQuestion();
      }

      questionEl.textContent = `${num1} ${operator} ${num2}`;
      startTimer();
      // Count a new question only when it is generated
      counts.total += 1;
      updateStats();
    }

    function handleInput() {
      const val = answerInput.value;
      if (val === '') { checkBtn.disabled = true; return; }
      const n = Number(val);
      checkBtn.disabled = !(Number.isInteger(n) && n >= 0 && n <= 999);
    }

    function startTimer() {
      stopTimer();
      seconds = 0;
      timerEl.textContent = '0s';
      timer = setInterval(() => {
        seconds += 1; timerEl.textContent = `${seconds}s`;
      }, 1000);
    }

    function stopTimer() { if (timer) { clearInterval(timer); timer = null; } }

    function checkAnswer() {
      if (answered) return;
      const n = Number(answerInput.value);
      if (!Number.isInteger(n) || n < 0 || n > 999) return;

      answered = true;
      stopTimer();
      checkBtn.disabled = true;
      nextBtn.disabled = false;

      if (n === correctResult) {
        resultEl.textContent = 'Correct!';
        resultEl.classList.add('ok');
        explanationEl.textContent = '';
        counts.correct += 1;
      } else {
        resultEl.textContent = 'Incorrect.';
        resultEl.classList.add('bad');
        correctValueEl.textContent = `Correct answer: ${correctResult}`;
        showStandardAlgorithm(num1, num2, operator, correctResult);
        counts.incorrect += 1;
      }
      updateStats();
    }

    function updateStats() {
      totalCountEl.textContent = counts.total;
      correctCountEl.textContent = counts.correct;
      incorrectCountEl.textContent = counts.incorrect;
      const acc = counts.total ? (counts.correct / counts.total) * 100 : 0;
      correctRateEl.textContent = `${acc.toFixed(1)}%`;
    }

    function resetStats() {
      counts = { total: 0, correct: 0, incorrect: 0 };
      updateStats();
      generateQuestion();
      clearCanvas();
    }

    function showStandardAlgorithm(a, b, op, ans) {
      // Render a simple vertical algorithm view
      const w = Math.max(String(a).length, String(b).length) + 2; // room for operator
      const line1 = `${String(a).padStart(w, ' ')}`;
      const line2 = `${op}${String(b).padStart(w - 1, ' ')}`;
      const sep = '-'.repeat(w);
      const line3 = `${String(ans).padStart(w, ' ')}`;
      explanationEl.textContent = `${line1}
${line2}
${sep}
${line3}`;
    }

    // ------- Scratchpad (pointer events: mouse + touch + pen) -------
    function setupCanvas() {
      ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      const cssWidth = rect.width; const cssHeight = rect.height;
      // Resize for device pixel ratio for crisp lines
      const ratio = Math.max(1, window.devicePixelRatio || 1);
      if (canvas.width !== Math.floor(cssWidth * ratio) || canvas.height !== Math.floor(cssHeight * ratio)) {
        canvas.width = Math.floor(cssWidth * ratio);
        canvas.height = Math.floor(cssHeight * ratio);
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      }
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#0f172a';
      clearCanvas();
    }

    function clearCanvas() {
      if (!ctx) return; // setup may not have run yet
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, rect.width, rect.height);
      ctx.beginPath();
    }

    function posFromEvent(e) {
      const r = canvas.getBoundingClientRect();
      if (e.touches && e.touches[0]) {
        return { x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top };
      }
      return { x: e.clientX - r.left, y: e.clientY - r.top };
    }

    function pointerDown(e) {
      e.preventDefault();
      if (canvas.setPointerCapture && e.pointerId !== undefined) {
        try { canvas.setPointerCapture(e.pointerId); } catch (_) {}
      }
      isDrawing = true;
      const { x, y } = posFromEvent(e);
      lastX = x; lastY = y;
      ctx.beginPath();
      ctx.moveTo(x, y);
    } = posFromEvent(e);
      lastX = x; lastY = y;
      ctx.beginPath();
      ctx.moveTo(x, y);
    }
    function pointerMove(e) {
      if (!isDrawing) return;
      e.preventDefault();
      const { x, y } = posFromEvent(e);
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x; lastY = y;
    } = posFromEvent(e);
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x; lastY = y;
    }
    function pointerUp(e) {
      isDrawing = false;
      ctx.closePath();
    }

    // Prefer Pointer Events; fall back to touch/mouse
    function bindPadEvents() {
      // Disable right-click menu on the canvas to keep drawing uninterrupted
      canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

      if (window.PointerEvent) {
        canvas.addEventListener('pointerdown', pointerDown);
        canvas.addEventListener('pointermove', pointerMove);
        canvas.addEventListener('pointerup', pointerUp);
        canvas.addEventListener('pointercancel', pointerUp);
        canvas.addEventListener('pointerleave', pointerUp);
      } else {
        // Touch
        canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); isDrawing=true; const p=posFromEvent(e); ctx.beginPath(); ctx.moveTo(p.x,p.y); }, {passive:false});
        canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); if(!isDrawing) return; const p=posFromEvent(e); ctx.lineTo(p.x,p.y); ctx.stroke(); }, {passive:false});
        ['touchend','touchcancel'].forEach(ev=> canvas.addEventListener(ev, ()=>{ isDrawing=false; ctx.closePath(); }));
        // Mouse
        canvas.addEventListener('mousedown', (e)=>{ e.preventDefault(); isDrawing=true; const p=posFromEvent(e); ctx.beginPath(); ctx.moveTo(p.x,p.y); });
        canvas.addEventListener('mousemove', (e)=>{ if(!isDrawing) return; e.preventDefault(); const p=posFromEvent(e); ctx.lineTo(p.x,p.y); ctx.stroke(); });
        ['mouseup','mouseleave'].forEach(ev=> canvas.addEventListener(ev, ()=>{ isDrawing=false; ctx.closePath(); }));
      }
    } else {
        // Touch
        canvas.addEventListener('touchstart', (e)=>{ isDrawing=true; const p=posFromEvent(e); ctx.beginPath(); ctx.moveTo(p.x,p.y); }, {passive:false});
        canvas.addEventListener('touchmove', (e)=>{ if(!isDrawing) return; const p=posFromEvent(e); ctx.lineTo(p.x,p.y); ctx.stroke(); }, {passive:false});
        ['touchend','touchcancel'].forEach(ev=> canvas.addEventListener(ev, ()=>{ isDrawing=false; ctx.closePath(); }));
        // Mouse
        canvas.addEventListener('mousedown', (e)=>{ isDrawing=true; const p=posFromEvent(e); ctx.beginPath(); ctx.moveTo(p.x,p.y); });
        canvas.addEventListener('mousemove', (e)=>{ if(!isDrawing) return; const p=posFromEvent(e); ctx.lineTo(p.x,p.y); ctx.stroke(); });
        ['mouseup','mouseleave'].forEach(ev=> canvas.addEventListener(ev, ()=>{ isDrawing=false; ctx.closePath(); }));
      }
    }

    clearPadBtn.addEventListener('click', clearCanvas);

    // ------- Events -------
    answerInput.addEventListener('input', handleInput);
    checkBtn.addEventListener('click', checkAnswer);
    nextBtn.addEventListener('click', generateQuestion);
    resetStatsBtn.addEventListener('click', resetStats);

    // ------- PWA (optional) -------
    if ('serviceWorker' in navigator) {
      try { navigator.serviceWorker.register('sw.js'); } catch (_) {}
    }

    // Init
    function init() {
      setMode(mode);
      setupCanvas();
      bindPadEvents();
      // Resize observer to keep canvas crisp when layout changes
      let resizeTimer;
      window.addEventListener('resize', () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(setupCanvas, 150); });
    }
    // Wait a tick for layout to settle so canvas size is correct
    window.requestAnimationFrame(init);
  </script>
</body>
</html>
